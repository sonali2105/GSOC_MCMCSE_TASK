# TASKS OF THE PROJECT

## Easy:
___
(1) 
Download the mcmcse package from CRAN and use the function ess on a vector foo of length 1e4 randomly drawn from a standard normal distribution. (2) Make a random matrix of size 10 x 10 and produce only the eigenvalues of the matrix.

## Medium:
___ 
Write a function that runs a Gaussian AR(1) model and use mcmcse to estimate the effective sample size.

## Hard:
___ 
Implement the replicated batch means estimator from this paper.

# SOLUTION

* First import the __MCMCSE__ package by the following code-

```R language
install.package("mcmcmse")
```
# rnorm()
* rnorm generates a vector of normally distributed random numbers.

* rnorm can take up to three arguments:
        
        n: the number of random variables to generate
        
        mean: if not specified defaults to 0.
        
        sd: the standard deviation. If not specified, defaults to 1.
# eigen()
* eigen is a generic function. The default method eigen.default computes eigenvalues and eigenvectors by providing an interface to the EISPACK routines RS, RG, CH and CG. eigen.Matrix provides an interface to the Lapack functions DSYEV and DGEEV.

```R language
## S3 method for class 'Matrix':
eigen(x, vectors = TRUE, balance = FALSE, 
   rcond = FALSE, \dots)
``` 
# arima.sim()

* The ARMA model is checked for stationarity.

   ARIMA models are specified via the order component of model, in the same way as for arima. Other aspects of the order component are ignored, but inconsistent specifications of the MA and AR orders are detected. The un-differencing assumes previous values of zero, and to remind the user of this, those values are returned.

  Random inputs for the ‘burn-in’ period are generated by calling rand.gen.

```R language
arima.sim(model, n, rand.gen = rnorm, innov = rand.gen(n, …),
          n.start = NA, start.innov = rand.gen(n.start, …),
          …)
```